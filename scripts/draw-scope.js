// Generated by CoffeeScript 1.8.0
(function() {
  var append, calcDerivatives, code, concat, drawPaths, drawUsage, inc, indentations, interpolateVerticalSquareWave, line, lineColor, lineCount, lineOfVariableUse, prepend, pxPerLine, reverse, slice, splitOnIdx, svg, usageCol, wait, walkPaths, xpos, ypos, _log, _logt, _ref;

  lineOfVariableUse = 4;

  usageCol = [22, 30];

  console.clear();

  _log = function() {
    console.log.apply(console, arguments);
    return arguments[0];
  };

  _logt = function(args) {
    _log(_.map(args, function(arr) {
      return "(" + (arr.join(',')) + ")";
    }));
    return args[0];
  };

  concat = function(arr1, arr2) {
    return arr1.concat(arr2);
  };

  prepend = function(val, arr) {
    return [val].concat(arr);
  };

  append = function(val, arr) {
    return arr.concat([val]);
  };

  slice = function(arr, start, count) {
    return arr.slice(start, count);
  };

  splitOnIdx = function(idx, arr) {
    return [_.first(arr, idx + 1), slice(arr, idx + 1)];
  };

  reverse = function(arr) {
    return arr.reverse();
  };

  inc = function(cnt, arr) {
    return _.map(arr, function(x) {
      return x + cnt;
    });
  };

  calcDerivatives = function(vector) {
    switch (false) {
      case !(vector.length <= 1):
        return [];
      default:
        return prepend(vector[0] - vector[1], calcDerivatives(_.tail(vector)));
    }
  };

  code = d3.select('#code');

  svg = code.append('svg');

  _ref = (function() {
    var lines;
    lines = code.select('pre').node().innerHTML.split('\n');
    return [
      lines.length, lines.map(function(line) {
        return /^\s*/.exec(line)[0].length;
      })
    ];
  })(), lineCount = _ref[0], indentations = _ref[1];

  pxPerLine = code.select('pre').node().scrollHeight / lineCount;

  xpos = function(d) {
    return 10 + 7 * d;
  };

  ypos = function(d, t) {
    return t * pxPerLine;
  };

  lineColor = function(c, node) {
    return node.attr('stroke-width', 2).attr('fill', 'none').attr('stroke', c);
  };

  interpolateVerticalSquareWave = function(points) {
    var intermediate;
    switch (false) {
      case points.lenght !== 0:
        return [];
      case points.length !== 1:
        return [points[0], [points[0][0], points[0][1] + pxPerLine]];
      default:
        intermediate = [points[0][0], points[1][1]];
        return concat([points[0], intermediate], interpolateVerticalSquareWave(_.tail(points)));
    }
  };

  line = d3.svg.line().x(xpos).y(ypos).interpolate(interpolateVerticalSquareWave);

  drawPaths = function() {
    var len, path;
    path = lineColor('brown', svg.append('path').attr('d', line(indentations)));
    len = path.node().getTotalLength();
    return path.attr('stroke-dasharray', '0 ' + len).attr('stroke-dashoffset', len / 2).transition().duration(1000).attr('stroke-dasharray', len + ' 0').attr('stroke-dashoffset', len);
  };

  drawUsage = function() {
    var usageLine;
    usageLine = d3.svg.line().x(function() {
      return -10 + xpos.apply(null, arguments);
    }).y(2 * pxPerLine + ypos(null, lineOfVariableUse));
    return lineColor('red', svg.append('path').attr('d', usageLine(usageCol)));
  };

  walkPaths = function() {
    var after, before, breaks, clip, indents, setClipPath, smoothOutDips, smoothedIndents, splitIndents, step;
    splitIndents = function(arr) {
      var splitUp;
      splitUp = splitOnIdx(lineOfVariableUse, arr);
      return [reverse(splitUp[0]), splitUp[1]];
    };
    indents = splitIndents(indentations);
    smoothOutDips = function(rest) {
      var current, next;
      if (rest.length < 2) {
        return rest;
      }
      current = rest[0];
      next = rest[1] > current ? current : rest[1];
      return prepend(current, smoothOutDips(prepend(next, slice(rest, 2))));
    };
    before = smoothOutDips(indents[0]);
    after = smoothOutDips(indents[1]);
    smoothedIndents = concat(reverse(before), after);
    breaks = (function() {
      var b, derivatives, findIdx, getBreaks;
      derivatives = _log(calcDerivatives(smoothedIndents));
      findIdx = function(startAt, step, ifNotFound, test) {
        var endAt, idx;
        endAt = step < 0 ? 0 : derivatives.length;
        idx = _.find(_.range(startAt, endAt, step), function(i) {
          return test(derivatives[i]);
        });
        if (idx != null) {
          return idx;
        } else {
          return ifNotFound;
        }
      };
      getBreaks = function(start, end) {
        var e, s;
        if (start === 0 && end >= derivatives.length - 1) {
          return [[start, end]];
        }
        s = findIdx(start - 1, -1, 0, function(x) {
          return x < 0;
        });
        e = findIdx(end + 1, 1, derivatives.length, function(x) {
          return x > 0;
        });
        return prepend([start, end], getBreaks(s, e));
      };
      b = getBreaks(lineOfVariableUse - 1, findIdx(lineOfVariableUse, 1, derivatives.length, function(v) {
        return v > 0;
      }));
      return append([0, indentations.length], _.map(b, function(t) {
        return inc(1, t);
      }));
    })();
    clip = svg.append('defs').append('clipPath').attr('id', 'visible-smoothed').append('rect').attr('x', 0).attr('width', '100%').attr('y', 0).attr('height', '100%');
    setClipPath = function(step) {
      var bk;
      bk = breaks[step];
      return clip.attr('y', pxPerLine * bk[0] + 1).attr('height', pxPerLine * (bk[1] - bk[0]) - 2);
    };
    step = 0;
    setClipPath(step);
    d3.select('button.next-scope').attr('disabled', null).node().addEventListener('click', function() {
      return setClipPath((step += 1) % breaks.length);
    });
    line = lineColor('lime', svg.append('g').attr('transform', 'translate(-2, 0)').append('path').attr('d', line(smoothedIndents)).attr('stroke-width', 1).attr('clip-path', 'url(#visible-smoothed)'));
    return line.attr('stroke-width', 1);
  };

  wait = function(ms) {
    return function() {
      var d;
      d = Q.defer();
      setTimeout(d.resolve, ms);
      return d.promise;
    };
  };

  (wait(1000)()).then(drawUsage).then(wait(2000)).then(drawPaths).then(wait(2000)).then(function() {
    return code.classed('rotate', true);
  }).then(wait(2000)).then(function() {
    return code.classed('rotate', false);
  }).then(wait(1000)).then(walkPaths).done();

}).call(this);
